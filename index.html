<!DOCTYPE html>
<html lang="en">
<head>
    <title>Generation Map</title>
    <meta property="og:description" content="Geographic Visualisation of GB Power Stations" />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@5.4.0/dist/maplibre-gl.css' />
    <link rel='stylesheet' href='generatorMap.css' />
    <script src='https://unpkg.com/maplibre-gl@5.4.0/dist/maplibre-gl.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
    <script src='generatorMap.js'></script>
</head>
<body>


<div id="map"></div>
<nav id="filter-group" class="filter-group"></nav>

<script>    
    const radiusCenter = [-4.07, 55.73];
    
    const filterGroup = document.getElementById('filter-group');
    
    const map = new maplibregl.Map({
        container: 'map',
        zoom: 5,
        center: radiusCenter,
        style: 'https://api.maptiler.com/maps/dataviz/style.json?key=y8C2n98M5Gq1bNIROgJt', 
        maxZoom: 20,
        minZoom: 5,
        maxPitch: 85
    });

    let scale = new maplibregl.ScaleControl({
        maxWidth: 80,
        unit: 'metric'  // 'imperial' or 'metric'
    });
    map.addControl(scale, 'bottom-left');

    // map.on('zoom', ()=>{
    //     console.log(map.getZoom());
    //     //map.triggerRepaint(); // Trigger a repaint to update the scale control
    //     //map.repaint();
    // });
    
    

    map.on('load', async () => {
        // Generate a polygon using turf.circle
        // See https://turfjs.org/docs/#circle
        console.log("Map loaded");

        let generators = await getGenerators(); // get the generator data from the generators.json file
                
        //For each generator, create a circle with a radius of 20*installedCapacity. Store the circle in a GeoJSON string.
        let generatorLocations = `\{
    \"type\": \"FeatureCollection\",
    \"features\": \[`;
        let generatorLocationsJSON = {};
        let bmuString = "";

        const options = {
            steps: 20,
            units: 'meters',
        };
    
        for(i in generators){
            //This for loop iterates through the generators JSON file and creates a circle for each generator. While it is 
            //at it, it also creates a string of BMU units to facilitate the request to the Elexon API to get all relevant 
            //Physical Notices (PNs).

            let outerRadius = parseFloat(generators[i].installedCapacity)*50/Math.E;
            
            let circle = {};
            circle = turf.circle([parseFloat(generators[i].lon), parseFloat(generators[i].lat)], outerRadius, options);
            circle.properties.name = generators[i].siteName;
            circle.properties.installedCapacity = generators[i].installedCapacity;
            circle.properties.primaryFuel = generators[i].primaryFuel;
            circle.properties.LngLatLike = [parseFloat(generators[i].lon), parseFloat(generators[i].lat)];
            
            generatorLocations += JSON.stringify(circle) + ",";

            for (j in generators[i].relevantBMU){
                //This inner for loop iterates through the relevantBMU array in the generator JSON file and creates a string of BMU units
                //to facilitate the request to the Elexon API to get all relevant Physical Notices (PNs).
                if(!generators[i].relevantBMU[j]==""){
                    bmuString += "&bmUnit=" + generators[i].relevantBMU[j];
                }
            }
        }//for
        
        bmuString += "&";

        //get the PNs associated with each BMU from the Elexon API
        let allPNs = await getPNs(bmuString); 

        console.log(allPNs);
        
        /***********
         * Complete the GeoJSON string for each circle/generation type, and provide a colour palette for each type.
         **/

        generatorLocations = generatorLocations.substring(0, generatorLocations.length - 1) + `\]}`;
        generatorLocationsJSON = JSON.parse(generatorLocations);
        
        layerArray=[];

        generatorLocationsJSON.features.forEach((feature) => {
            const layerID = feature.properties['primaryFuel'];

            // Add a layer for this symbol type if it hasn't been added already.
            if (!layerArray.includes(layerID)) {
                layerArray.push(layerID);
            }
        });

        /**
         * Add the powerstation layer to the map
         * The data is in GeoJSON format, so we can add it as a source
         * and then add a fill layer and an outline layer to display it.
         **/
        for (eachLayer in layerArray){
            //console.log(layerArray[eachLayer]);
            let sourceObject = {
                name: `${layerArray[eachLayer]}`,
                data: generatorLocationsJSON,
            };
            let fillObject = {
                name: `${layerArray[eachLayer]}-fillLayer`,
            };
            let lineObject = {
                name: `${layerArray[eachLayer]}-lineLayer`,
            };

            //console.log(sourceObject, fillObject, lineObject);
            
            addFuelLayer(sourceObject, fillObject, lineObject, map);

            // Add checkbox and label elements for the layer.
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.id = layerArray[eachLayer];
            input.checked = true;
            filterGroup.appendChild(input);

            const label = document.createElement('label');
            label.setAttribute('for', layerArray[eachLayer]);
            label.textContent = layerArray[eachLayer];
            filterGroup.appendChild(label);

            // When the checkbox changes, update the visibility of the layer.
            input.addEventListener('change', (e) => {
                //console.log(e.target.id);
                map.setLayoutProperty(
                    `${e.target.id}-fillLayer`,
                    'visibility',
                    e.target.checked ? 'visible' : 'none'
                );
            });
        }
    });//map.on('load', ...) function

    // When a click event occurs on a feature in the places layer, open a popup at the
    // location of the feature, with description HTML from its properties.
    map.on('click', 'Wind-fillLayer', (e)=> {
        getGenInfo(e);
    });
    map.on('click', 'Natural Gas-fillLayer', (e) => {
        getGenInfo(e);
    });
    map.on('click', 'Nuclear-fillLayer', (e) => {
        getGenInfo(e);
    });
    map.on('click', 'Diesel/Gas Oil-fillLayer', (e) => {
        getGenInfo(e);
    });
    map.on('click', 'Biomass-fillLayer', (e) => {
        getGenInfo(e);
    });
    map.on('click', 'Coal-fillLayer', (e) => {
        getGenInfo(e);
    });
    map.on('click', 'Sour Gas-fillLayer', (e) => {
         getGenInfo(e);
    });
    map.on('click', 'Solar-fillLayer', (e) => {
         getGenInfo(e);
    });
    map.on('click', 'Hydro-fillLayer', (e) => {
         getGenInfo(e);
    });
    map.on('click', 'Pumped hydro-fillLayer', (e) => {
         getGenInfo(e);
    });
    
</script>
</body>
</html>